### 种类和作用：
1、代码段寄存器CS（Code Segment）

存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供。

2、数据段寄存器DS（Data Segment）

指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。

3、堆栈段寄存器SS（Stack Segment）

指出当前堆栈的底部地址，即存放堆栈段的段基址。

4、附加段寄存器ES（Extra Segment）

指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段。


## 2.1 段选择子结构
eg:0x0023
```
00100 | 0 | 11
index | TI| RPL
```
* index 在gdt数组或LDT数组的索引号
* TI table indicator ,0表示查找GDT 1表示查找LDT
* RPL 请求特权级，以什么样的权限去访问段

## 2.2 段描述符结构

eg: 00cff300`0000ffff
```
0000  0000 | 1  1  0 0  | 1111        | 1 11  1 0011| 0000 0000 |
base[31-24]| G|D/B|0|AVL| limit[19-16]| P|DPL|S|TYPE| 

0000 0000 0000 0000 | 1111 1111 1111 1111 |
base[23-0]          | limit[15-0]
```

* BASE: 段基址，由上图中的两部分(BASE 31-24 和 BASE 23-0)组成
* G：LIMIT的单位，该位 0 表示单位是字节，1表示单位是 4KB
* D/B: 该位为 0 表示这是一个 16 位的段，1 表示这是一个 32 位段
* AVL: 该位是用户位，可以被用户自由使用
* LIMIT: 段的界限，单位由 G 位决定。数值上（经过单位换算后的值）等于段的长度（字节）- 1。
* P: 段存在位，该位为 0 表示该段不存在，为 1 表示存在。
* DPL：段权限
* S: 该位为 1 表示这是一个数据段或者代码段。为 0 表示这是一个系统段（比如调用门，中断门等）
* TYPE: 根据 S 位的结果，再次对段类型进行细分。

### 分段机制
* 一般情况下，数据段是非一致的，权限高的可以访问权限低的。代码段要求平级访问，就算权限高也不能访问。访问者没有必要也不可能降低身份去访问权限低的代码。
* 处理器从高特权级降低到低特权级：中断处理程序返回到用户态的时候。
* 代码段有一致性和非一致性，但是数据段总是非一致性。
* 一致性代码段 = 共享代码段 = 特权级变化访问高特权级代码
* 非一致性代码段 = 代码段必须平级访问 = 非一致性数据段可以高级别访问


* 代码段必须不可写，其他段根据段属性划分可读可写。
* 我们在执行mov ds, ax这样的指令的时候，明明 ax 只有 16 位，可是，段寄存器却有96位？这又是怎么回事？
* GDT 表是全局描述符表，LDT 表是局部描述符表。当我们写段寄存器的时候，只给了16位，剩下80位并未给出，其实这80位的数据将通过查 GDT 表或者 LDT 表来获得。GDT 表和 LDT 表实际上就是一个大数组，数组中的每一项占用 8 个字节。
* 16位选择子作为索引去GDT表查找对应段描述符

* 第4章-80x86保护模式及其编程 <https://github.com/yifengyou/linux-0.12/blob/master/docs/%E7%AC%AC4%E7%AB%A0-80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B/%E7%AC%AC4%E7%AB%A0-80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B.md>

* CSDN博客 - OS 学习笔记导航 - <https://blog.csdn.net/q1007729991/article/details/52538571>
